#!/usr/bin/env python

import argparse
import os.path
import time
import threading
import subprocess
import re


_FILENAME = os.path.abspath(__file__)
_DIRNAME = os.path.dirname(_FILENAME) + '/collectors'

def touch(fname, times = None):
    # emulate /usr/bin/touch
    with file(fname, 'a'):
        os.utime(fname, times)

def utime(fname):
    try:
        return os.stat(fname).st_mtime
    except Exception:
        return 0

_NAGIOS_VALUE = re.compile(r"(?P<key>[^=\s]+)=(?P<value>[-+]?[0-9]*\.?[0-9]+)(?P<uom>(us|ms|s|%|MB|KB|TB|B))?")
_CRONTAB_TOKEN = '# zcollector DO NOT EDIT'
if 'ZENHOME' in os.environ:
   _PERFDIR = os.path.join(os.environ['ZENHOME'], 'perf/Daemons/localhost')
else:
   _PERFDIR = '/tmp'


RRDCreateCommand = (""" \
    rrdtool create %(filename)s \
    DS:ds0:%(metricType)s:%(heartbeat)s:%(minVal)s:%(maxVal)s \
    RRA:AVERAGE:0.5:1:600 \
    RRA:AVERAGE:0.5:6:600 \
    RRA:AVERAGE:0.5:24:600 \
    RRA:AVERAGE:0.5:288:600 \
    RRA:MAX:0.5:6:600 \
    RRA:MAX:0.5:24:600 \
    RRA:MAX:0.5:288:600 """
)

RRDUpdateCommand = "rrdtool update %(filename)s N:%(value)s"


class CmdCollector(threading.Thread):

    def __init__(self, cmd, path, interval):
        self._cmd = cmd
        self._path = path
        self._interval = interval
        super(self.__class__, self).__init__()

    def run(self):
        p = subprocess.Popen(self._cmd, stdout=subprocess.PIPE)
        stdout, stderr = p.communicate()
        for line in stdout.splitlines():
            for part in line.split():
                match = _NAGIOS_VALUE.search(part)
                if match:
                    value = float(match.group('value'))
                    key = match.group('key')
                    uom = '' if match.group('uom') is None else match.group('uom')
                    self.save(key, value, uom)

    def save(self, key, value, uom):
        basename = self._cmd[0].split('/')[-1] + '_' + key + '.rrd'
        filename = os.path.join(self._path, basename)
        if not os.path.isfile(filename):
            heartbeat = self._interval * 3
            minVal = 0
            maxVal = 4294967295
            if uom == 'c':
                metricType = 'COUNTER'
            else:
                metricType = 'GAUGE'
            cmd = RRDCreateCommand % locals()
            subprocess.check_call(cmd, shell=True)
        
        # save!
        cmd = RRDUpdateCommand % locals()
        subprocess.check_call(cmd, shell=True)
 
        

class ZCollector(object):


    def _getCronTab(self):
        try:
            return subprocess.check_output("crontab -l", shell=True)
        except subprocess.CalledProcessError:
            return ''

    def _addEntry(self, crontab):
        env = "ZENHOME=%(ZENHOME)s PYTHONPATH=%(PYTHONPATH)s PATH='%(PATH)s' " % os.environ
        newline = '* * * * * %s %s --silent run %s' % (env, _FILENAME, _CRONTAB_TOKEN)
        newparts = []
        added = False
        for line in crontab.splitlines():
            if line.strip().endswith(_CRONTAB_TOKEN):
                if not added:
                    newparts.append(newline)
                    added = True
            else:
                newparts.append(line)
        if not added:
            newparts.append(newline)
        return "\n".join(newparts) + "\n"

    def _installTab(self, crontab):
        p = subprocess.Popen("crontab -", shell=True, stdin=subprocess.PIPE)
        p.stdin.write(crontab)
        p.stdin.close()
        p.wait()

    def init(self, args, parser):
        currentTab = self._getCronTab()
        newTab = self._addEntry(currentTab)
        if currentTab != newTab:
            print newTab
            self._installTab(newTab)
            print "Installed new tab"
     

    def run(self, args, parser):
        if not os.path.isdir(args.dirname):
            parser.exit("%s directory does not exists. "
                "Use --dirname to set collectors directory." % args.dirname)
        dirs = os.listdir(args.dirname)
        collectorDirs = {}
        for path in dirs:
            fullpath = os.path.abspath(os.path.join(args.dirname, path))
            if os.path.isdir(fullpath) and path.isdigit():
                collectorDirs[int(path)] = os.path.abspath(os.path.join(args.dirname, path))

        # execute all our tasks!
        for interval, path in collectorDirs.items():
            # get previous run time
            tfile = os.path.join(path, ".zcollector")
            last = utime(tfile)
            if (time.time() - last) > interval or args.force:
                if not args.silent:
                    print "Executing all daemons in: %s" % path
                files = os.listdir(path)
                start = time.time()
                threads = []
                for fname in files:
                    filename = os.path.join(path, fname)
                    if os.path.isfile(filename) and os.access(filename, os.X_OK):
                        if not args.silent:
                            print "Executing %s" % filename
                        if not os.path.exists(args.perfdir):
                            os.makedirs(args.perfdir)
                        thread = CmdCollector([filename], args.perfdir, interval)
                        thread.start()
                # join all out threads
                for thread in threads:
                    elapsed = time.time() - start
                    timeout = 1 if elapsed > 60 else 60 - elapsed
                    thread.join(timeout)

            # mark the directory as executed
            touch(tfile)
            


    def main(self):
        parser = argparse.ArgumentParser()
        subparsers = parser.add_subparsers()

        # create a parser for the init command
        parser_init = subparsers.add_parser('init')
        parser_init.set_defaults(func=self.init)

        # create a parser for the run command
        parser_run = subparsers.add_parser('run')
        parser_run.add_argument('--dirname', default=_DIRNAME)
        parser_run.add_argument('--perfdir', default=_PERFDIR)
        parser_run.add_argument('--force', action='store_true')
        parser_run.set_defaults(func=self.run)

        parser.add_argument('--silent', action='store_true')

        args = parser.parse_args()
        args.func(args, parser)

if __name__=='__main__':
    zcollector = ZCollector()
    zcollector.main() 

