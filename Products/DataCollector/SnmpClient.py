import socket
import logging
log = logging.getLogger("zen.SnmpClient")

from twisted.internet import reactor, error, defer
from twisted.python import failure
from twistedsnmp import snmpprotocol, agentproxy

import Globals

from Products.ZenUtils.IpUtil import isip
from Products.ZenUtils.NJobs import NJobs

global defaultTries, defaultTimeout
defaultTries = 2
defaultTimeout = 1

DEFAULT_MAX_OIDS_BACK = 40

class SnmpClient(object):

    def __init__(self, hostname, ipaddr, options=None, device=None, 
                 datacollector=None, plugins=[]):
        global defaultTries, defaultTimeout
        self.hostname = hostname
        self.device = device
        self.options = options
        self.datacollector = datacollector
        self.plugins = plugins

        self._getdata = {}
        self._tabledata = {}

        community = getattr(device, 'zSnmpCommunity', "public")
        port = int(getattr(device, 'zSnmpPort', 161))
        snmpver = getattr(device, 'zSnmpVer', "v1")
        self.tries = int(getattr(device,'zSnmpTries', defaultTries))
        self.timeout = float(getattr(device,'zSnmpTimeout', defaultTimeout))

        #ipaddr = socket.gethostbyname(hostname)
        srcport = snmpprotocol.port()
        self.proxy = agentproxy.AgentProxy(ipaddr, port, community, snmpver,
                                           protocol=srcport.protocol)


    def run(self):
        """Start snmp collection.
        """
        log.debug("timeout=%s, tries=%s", self.timeout, self.tries)
	jobs = NJobs(1, self.runOne, list(self.plugins))
	jobs.start().addBoth(self.clientFinished)

    def runOne(self, plugin):
        result = []
	log.debug('running %s', plugin)
        pname = plugin.name()
        self._tabledata[pname] = {}
        log.debug("sending queries for plugin %s", pname)
        if plugin.snmpGetMap:
            d = self.proxy.get(plugin.snmpGetMap.getoids(),
                               timeout=self.timeout, retryCount=self.tries)
            d.addCallback(self._snmpGetCallback, pname)
            d.addErrback(self._handleError, pname)
	    result.append(d)
        for tmap in plugin.snmpGetTableMaps:
            rowSize = len(tmap.getoids())
            maxRepetitions = max(DEFAULT_MAX_OIDS_BACK / rowSize, 1)
            d = self.proxy.getTable(tmap.getoids(),
                       timeout=self.timeout, retryCount=self.tries,
                       maxRepetitions=maxRepetitions)
            d.addCallback(self._snmpGetTableCallback, pname, tmap)
            d.addErrback( self._handleError, pname)
 	    result.append(d)
        return defer.DeferredList(result, consumeErrors=1)


    def _snmpGetCallback(self, results, pluginName):
        log.debug("received plugin:%s getOids", pluginName)
        self._getdata[pluginName] = results 
   

    def _snmpGetTableCallback(self, results, pluginName, tmap):
        log.debug("received plugin:%s table:%s", pluginName, tmap.name)
        self._tabledata[pluginName][tmap] = results


    def _handleError( self, err, pname):
        """Handle an error generated by one of our requests.
        """
        log.debug('device %s plugin %s %s', self.hostname, pname, err )
        if isinstance( err, failure.Failure ):
            actualError = err.value
            trace = err.getTraceback()
        else:
            actualError = err
            trace = log.getException( err )
        if not isinstance( actualError, error.TimeoutError ):
            log.error(
                """device %s plugin %s unexpected error: %s""",
                self.hostname, pname, trace,
            )
        return None


    def getResults(self):
        """Return data for this client in the form
        ((pname, (getdata, tabledata),)
        getdata = {'.1.2.4.5':"value",}
        tabledata = {tableMap : {'.1.2.3.4' : {'.1.2.3.4.1': "value",...}}} 
        """
        data = []
        for plugin in self.plugins:
            pname = plugin.name()
            getdata = self._getdata.get(pname,{})
            tabledata = self._tabledata.get(pname,{})
            if getdata or tabledata:
                data.append((pname, (getdata, tabledata)))
        return data 

    def clientFinished(self, *ignored):
        """tell the datacollector that we are all done"""
        log.info("snmp client finished collection for %s" % self.hostname)
        if self.datacollector:
            self.datacollector.clientFinished(self)
        else:
            reactor.stop()



def buildOptions(parser=None, usage=None):
    "build options list that both telnet and ssh use"
   
    if not usage:
        usage = "%prog [options] hostname[:port] oids"

    if not parser:
        from optparse import OptionParser
        parser = OptionParser(usage=usage, 
                                   version="%prog " + __version__)
  
    parser.add_option('--snmpCommunity',
                dest='snmpCommunity',
                default=defaultSnmpCommunity,
                help='Snmp Community string')


if __name__ == "__main__":
    import pprint
    logging.basicConfig()
    log = logging.getLogger()
    log.setLevel(20)
    import sys
    sys.path.append("plugins")
    from plugins.zenoss.snmp.InterfaceMap import InterfaceMap
    ifmap = InterfaceMap()
    sc = SnmpClient("gate.confmon.loc", community="zentinel", plugins=[ifmap,])
    reactor.run()
    pprint.pprint(sc.getResults())
